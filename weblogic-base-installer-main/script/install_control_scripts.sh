#!/bin/bash
#
# Create scripts to start/stop WebLogic components
# Created: 2016-10-11 dkovacs of virtual7
#

cd "$(dirname $0)/.."; workdir="$(pwd)"
. $workdir/script/functions.sh

scriptdir="$ASERVER_HOME/custom_scripts"
mkdir -p "$scriptdir" || exit 1

msg "Creating start/stop scripts in $scriptdir"

header_msg="# This file was generated by the IuK37 Standard Installer version $wls_installer_version
# for WebLogic Server $weblogic_version on $(date).
# WARNING: Modifications to this file might get overwritten when the installer is run again."

# Create wlst.sh
cat >$scriptdir/wlst.sh <<EOF
#!/bin/bash
$header_msg
WLST_PROPERTIES="\${WLST_PROPERTIES} -Dweblogic.security.SSL.trustedCAKeyStore=$TRUST_STORE"
export WLST_PROPERTIES
"$ORACLE_HOME/oracle_common/common/bin/wlst.sh" "\$@"
EOF

# Create functions.sh
cat >$scriptdir/functions.sh <<EOF
$header_msg
EXPECTED_USER=$WLS_OS_USER   # the OS user allowed to run this script

# Read distribution information from /etc/os-release
if [ -f /etc/os-release ]; then
  source /etc/os-release
  OS_RELEASE="\${NAME}-\${VERSION}"
else
  OS_RELEASE="unknown"
fi 

umask 027

# Make sure the script sourcing this file can only run as \$EXPECTED_USER
if [ "\$(whoami)" != "\$EXPECTED_USER" ]; then
  echo "Error: you need to be \$EXPECTED_USER to run this script" >&2
  echo "Exiting"  >&2
  exit 1
fi


# Message to stdout and log file
msg() {
  echo -e "[\$(date +'%Y-%m-%dT%H:%M:%S')] [\$(hostname)] [\$(basename \$0)] [\$1]"
}

# Error message to stderr
err() {
  msg "ERROR: \$@" >&2
}

# Wrapper for wlst.sh to filter out unwanted informational messages.
wlstq() {
  local filter='^\$|Initializing WebLogic Scripting Tool|Welcome to WebLogic Server Administration Scripting Shell|Type help\(\) for help on available commands|<BEA-090905>|<BEA-090906>|<BEA-090908>|Location changed to .* tree|with .* as the root MBean|For more help, use help'
  "\$workdir/wlst.sh" "\$@"|egrep -v -E "\$filter"
}

# Check if any process matching the command line pattern \$1 is running
# on host \$2 under the current user. If not set, \$2 defaults to current host.
# If \$3 is set to "use_chache" then the check is performed against the process
# list stored by a previous check. This can be useful to prevent frequent ssh
# calls to retrieve the process list from remote hosts.
declare -A pscache
processIsRunning() {
  [ "\$1" ] || return 1

  local host="\$2"
  [ "\$host" ] || host="\$(hostname)"

  if [ "\${pscache[\$host]}" == "" ] || [ "\$3" != "use_cache" ]; then
    if [ "\$host" == "\$(hostname)" ]; then
      pscache["\$host"]="\$(ps xww)"
    else
      pscache["\$host"]="\$(ssh "\$host" "ps xww")"
    fi
  fi

  process="\$(echo "\${pscache["\$host"]}"|grep "\$1"|grep -v grep)"
  [ "\$process" ]
}

# Check if a weblogic server process with the specified server name is running
serverIsRunning() {
  if [ "\$1" == "\$(getAdminServerName)" ]; then
    processIsRunning ".*java.*/\${EXPECTED_USER}.*-Dweblogic.Name=\$(getAdminServerName).*-Dvirtual7.domainMarker=$DOMAIN_NAME .*weblogic.Server" "\${@:2}"
  else
    processIsRunning ".*java.*-Dweblogic.Name=\${1} .*-Dweblogic.system.BootIdentityFile=$MSERVER_HOME/servers/\${1}/data/nodemanager/boot.properties.*weblogic.Server" "\${@:2}"
  fi
}

# Check if the node manager process is running
nmIsRunning() {
  processIsRunning ".*java.*${DOMAIN_NAME} .*weblogic.NodeManager.*" "\${@:2}"
}

# Look up the IP for the specified name in DNS or /etc/hosts
getIPForName () {
  ( getent hosts "\$1" || host "\$1" ) | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | head -1
}


# Retrieve the administration server name from config.xml
getAdminServerName() {
  if [ -z "\$admin_server_name" ]; then
    admin_server_name="\$(xml_grep --text_only /domain/admin-server-name $ASERVER_HOME/config/config.xml)"
  fi
  echo "\$admin_server_name"
}

# Query config.xml using the specified xpath expression
queryConfigXML() {
  [ "\$1" ] || return 1
  if [[ "\$OS_RELEASE" == SLES-12-* ]]; then
    result="\$(xpath $ASERVER_HOME/config/config.xml "\$1" 2>/dev/null)"
  elif [[ "\$OS_RELEASE" == SLES-15-* ]]; then
    result="\$(xpath -q -e "\$1" $ASERVER_HOME/config/config.xml)"
  else
    return 1
  fi
  if [ "\$result" ]; then
    # remove xml tags from result
    echo "\$result" | xml_grep --text_only "\$(basename \$1)"
  fi
}

# Retrieve the listen address of the specified server from config.xml
getListenAddress() {
  [ "\$1" ] || return 1
  declare -A listen_address
  if [ -z "\${listen_address["\$1"]}" ]; then
    query="/domain/server[name='\$1']/listen-address"
    listen_address["\$1"]="\$(queryConfigXML \$query)"
  fi
  echo "\${listen_address["\$1"]}"
}

# Retrieve the SSL listen port of the specified server from config.xml
getSSLPort() {
  [ "\$1" ] || return 1
  declare -A ssl_port
  if [ -z "\${ssl_port["\$1"]}" ]; then
    query="/domain/server[name='\$1']/ssl/listen-port"
    ssl_port["\$1"]="\$(queryConfigXML \$query)"
  fi
  echo "\${ssl_port["\$1"]}"
}

# Retrieve the administration port of the specified server from config.xml
getAdminPort() {
  [ "\$1" ] || return 1
  declare -A admin_port
  if [ -z "\${admin_port["\$1"]}" ]; then
    query="/domain/server[name='\$1']/administration-port"
    admin_port["\$1"]="\$(queryConfigXML \$query)"
  fi
  echo "\${admin_port["\$1"]}"
}

# Return true if the administration port is enabled, otherwise return false
adminPortIsEnabled() {
  query="/domain/administration-port-enabled" 
  admin_port_enabled="\$(queryConfigXML \$query)"
  [ "\$admin_port_enabled" == "true" ]
}



# True if the network interface with the IP for the admin server's listen address is up
adminInterfaceIsUp() {
  [ "\$(ip a|grep "inet \$(getIPForName \$(getListenAddress \$(getAdminServerName)))/")" ]
}

# Read domain configuration information from config.xml
readDomainConfig() {
  DOMAIN_SERVER_LIST=(\$(xml_grep --text_only /domain/server/name $ASERVER_HOME/config/config.xml|sort))
  DOMAIN_MACHINE_LIST=(\$(xml_grep --text_only /domain/machine/name $ASERVER_HOME/config/config.xml|sort))
}

# Releases the lock with the ID \$1
releaseLock() {
  [ "\$1" ] || return 1
  lockdir="\$workdir/tmp/\$1"
  if [ -f "\$lockdir/owner" ]; then
    owner="\$(<"\$lockdir/owner")"
    if [ "\$owner" == "\$(hostname) \$\$" ]; then
      rm -rf "\$lockdir" &&
      msg "Lock released: \$1"
    else
      err "Cannot remove lock \$1. Not owner."
      return 1
    fi
  fi
}

# Obtains the mutex lock with ID \$1
getLock() {
  [ "\$1" ] || return 1
  lockdir="\$workdir/tmp/\$1"
  mkdir -p "\$workdir/tmp"

  # Try to create the lock directory
  if mkdir "\${lockdir}" 2>/dev/null; then
    # Lock succeeded
    # set up signal handler
    trap "releaseLock \$1" EXIT
    # owned by this process on this host
    echo "\$(hostname) \$\$" >"\$lockdir/owner"
    msg "Lock acquired: \$1"
    return 0
  else
    # Lock failed. Check if owner is running.
    if owner="\$(<"\$lockdir/owner")"; then
      ownerhost=\$(echo \$owner|cut -d ' ' -f 1)
      ownerpid=\$(echo \$owner|cut -d ' ' -f 2)
      if [ "\$ownerhost" == "\$(hostname)" ]; then
        kill -0 \$ownerpid
      else
        ssh \$ownerhost "kill -0 \$ownerpid"
      fi
      if [ \$? != 0 ]; then
        # lock is stale, remove it and retry
        rm -rf "\$lockdir" &&
          msg "Removed stale lock \$1" &&
          getLock "\$1" ||
          return 1
      else
        msg "Cannot acquire lock \$1. It is owned by PID \$ownerpid on host \$ownerhost"
        return 1
      fi
    else
      msg "Cannot acquire lock \$1."
      return 1
    fi
  fi
}

# Bring down the admin server's floating IP
flipDown() {
  if adminInterfaceIsUp; then
    if serverIsRunning "\$(getAdminServerName)"; then
      err "Cannot remove the floating IP from interface $ADMIN_FLIP_IF becasue the administration server is still running."
      rc=1
    else
      admin_ip=\$(getIPForName \$(getListenAddress \$(getAdminServerName))) # get the IP for the listen address
      if [ -z "\$admin_ip" ]; then
        err "Cannot deactivate the admin server floating IP address because \$(getListenAddress \$(getAdminServerName)) cannot be resolved to an IP address." >&2
        return 1
      fi
      netprefix="\$(ip -o -f inet addr show $ADMIN_FLIP_IF | awk '{split(\$4, a, "/"); print a[2]}' | head -1)"
      sudo ip a del \$admin_ip/\$netprefix dev $ADMIN_FLIP_IF &&
        msg "Floating IP \$admin_ip removed from interface $ADMIN_FLIP_IF"
      rc=\$?
    fi
  else
    msg "Floating IP \$admin_ip is already down on host \$(hostname)"
    rc=10
  fi
  return \$rc
}
EOF

# Create command-control.sh
cat >$scriptdir/command-control.sh <<EOF
#!/bin/bash
$header_msg
#
# Start, stop or show the status of WebLogic Servers
cd \$(dirname \$0); workdir="\$(pwd)"
. "\$workdir/functions.sh"

admin_flip_enabled="$([ "$HA_DOMAIN" == "true" ] && [ "$ADMIN_FLIP_ENABLED" = "true" ] && echo "true" || echo "false")"
ha_domain="$HA_DOMAIN"
rotate_aserver_out_on_startup="true"
admin_server_start_timeout="$ASERVER_START_TIMEOUT"  # timeout in seconds for starting the administration server

usage_msg="Usage:

    \$(basename \$0) <start|stop|graceful_stop|multistart|multistop|graceful_multistop> <server|cluster|machine|all>...
    \$(basename \$0) <wls-state> <server|cluster|machine|all>...
    \$(basename \$0) <status> <server|all>...
    \$(basename \$0) <nmstart|nmstop|nmstatus> [machine|all]...

    Options for server operations:
        start
            Start the servers sequentially in the order as specified

        stop
            Stop the serevers sequentially in the order as specified
        
        graceful_stop
            Wait for application processing to complete before stopping the servers sequentially

        multistart
            Start multiple servers simultaneously

        multistop
            Stop multiple servers simultaneously
        
        graceful_multistop
            Wait for application processing to complete before stopping the servers simultaneously

        status
            Show the JVM process status (up/down) of servers

        wls-state
            Show the server life cycle state

        server
            The name of a WebLogic Server

        cluster
            The name of a WebLogic Cluster. The cluster name will be resolved to all servers in the cluster.

        machine
            The name of a WebLogic Machine. The machine name will be resolved to all servers assigned to the machine.

        all
            The string \\"all\\" will be resolved to all servers in the domain, including the administration server.

     Options for node manager operations:
        nmstart
            Start the node manager

        nmstop
            Stop the nodemanager

        nmstatus
            Show node manager status

        machine
            Machine name or \\"all\\" to select all machines.


    Examples:

        \$(basename \$0) nmstart poctvm0-1
            Start the node manager on machine \\"poctvm0-1\\".

        \$(basename \$0) nmstop all
            Stop the node managers on all machines.

        \$(basename \$0) start AdminServer mserver1 mserver2
            Start the servers AdminServer, mserver1 and mserver2 sequentially.

        \$(basename \$0) stop AdminServer mserver1 mserver2
            Stop the servers AdminServer, mserver1 and mserver2 sequentially.

        \$(basename \$0) start all
            Start all servers in the domain sequentially, including the administration server.

        \$(basename \$0) multistart all
            Start the administration server, then start all managed servers parallel.

        \$(basename \$0) start cluster1 cluster2
            Start all servers in \\"cluster1\\" and \\"cluster2\\".

        \$(basename \$0) start machine1
            Start all servers assigned to machine1.

        \$(basename \$0) status AdminServer mserver2
            Show the JVM process status for AdminServer and mserver2.

        \$(basename \$0) wls-state AdminServer mserver2
            Show the life cycle state for AdminServer and mserver2."

# Wait for the administration Server to become available.
# Timeout after \$1 seconds
waitForAdminServer() {
  declare -i timeout="\$1"
  declare -i interval=0
  if ((timeout > 0)); then
    interval=10
  fi

  if adminPortIsEnabled; then
    as_port="\$(getAdminPort \$(getAdminServerName))"
  else
    as_port="\$(getSSLPort \$(getAdminServerName))"
  fi

  # Try to connect
  until (echo >"/dev/tcp/\$(getListenAddress \$(getAdminServerName))/\$as_port") 2>/dev/null; do
    if ((timeout < 0)); then
      err "Error: Timeout after \$1 seconds of waiting for the Administration Server."
      return 2
    fi
    msg "Waiting for the Administration Server to start ..."
    sleep \$interval
    ((timeout-=interval))
  done
  msg "The Administration Server is available"
}

# Start the AdminServer
start_adminserver() {
  if serverIsRunning "\$(getAdminServerName)"; then
    pid="\$(echo \$process|cut -d ' ' -f 1)"
    msg "The Administration Server is already running with pid \$pid on host \$(hostname)"
    return 0
  fi


  # Make sure the network interface for the admin server's listen address is up
  msg "Preparing to start the Administration Server ..."
  if [ "\$ha_domain" == "true" ] && [ "\$admin_flip_enabled" == "true" ]; then
    # Make sure the network interface for the admin server's listen address is up
    admin_ip=\$(getIPForName \$(getListenAddress \$(getAdminServerName))) # get the IP for the listen address
    if [ -z "\$admin_ip" ]; then
      err "Cannot start the Administration Server. \$(getListenAddress \$(getAdminServerName)) cannot be resolved." >&2
      return 1
    fi
    if adminInterfaceIsUp; then
      msg "Network interface $ADMIN_FLIP_IF for \$admin_ip/\$(getListenAddress \$(getAdminServerName)) is up."
    else
      if ping -c 1 -W 3 \$admin_ip >/dev/null; then
        msg "The Administration Server will not be started because the configured listen address \$admin_ip/\$(getListenAddress \$(getAdminServerName)) seems to be alive on another host."
        return 0
      else
        netprefix="\$(ip -o -f inet addr show $ADMIN_FLIP_IF | awk '{split(\$4, a, "/"); print a[2]}' | head -1)"
        sudo ip a add \$admin_ip/\$netprefix dev $ADMIN_FLIP_IF
        if adminInterfaceIsUp; then
          sudo arping -q -U -c 3 -I $(echo $ADMIN_FLIP_IF|cut -d ':' -f 1) \$admin_ip
          msg "Activated the network interface $ADMIN_FLIP_IF for \$admin_ip/\$(getListenAddress \$(getAdminServerName))"
        else
          msg "Failed to activate the IP adress \$admin_ip on interface $ADMIN_FLIP_IF" >&2
          return 1
        fi
      fi
    fi
  elif [ "\$ha_domain" == "true" ] && [ "\$admin_flip_enabled" == "false" ]; then
    if adminInterfaceIsUp; then
      msg "The listen address \$(getListenAddress \$(getAdminServerName)) is available on this host - OK."
    else
      msg "The listen address \$(getListenAddress \$(getAdminServerName)) is NOT available on this host and the Administration Server will NOT be started here!"
      return 0
    fi
  fi

  # Rotate .out file
  outfile_current="$ASERVER_HOME/servers/\$(getAdminServerName)/logs/\$(getAdminServerName).out"
  mkdir -p "\$(dirname \$outfile_current)"
  if [ "\$rotate_aserver_out_on_startup" == "true" ]; then
    outfile_rotated="\$outfile_current"
    counter=0
    while [ -e "\$outfile_rotated" ]; do
      (( counter ++ ))
      outfile_rotated="\$outfile_current\$(printf "%05d" \$counter)"
    done
    [ -e "\$outfile_current" ] && mv "\$outfile_current" "\$outfile_rotated" && msg "Existing file \$(basename \$(getAdminServerName).out) has been renamed to \$(basename \$outfile_rotated)"
  fi

  # Start the Administration Server
  export USER_MEM_ARGS="$ASERVER_MEMORY" # this will override MEM_ARGS from setDomainEnv.sh
  export JAVA_OPTIONS="-Dvirtual7.domainMarker=$DOMAIN_NAME" # this will show up in the process commad line and can be used to identify the domain for the admin server process.
  msg "Starting the Administration Server on host \$(hostname) for domain $DOMAIN_NAME ... "
  nohup $ASERVER_HOME/startWebLogic.sh noderby >>\$outfile_current 2>&1 &
  sleep 3 # give the java process some time to start

  # Check if the Admin Server process is alive
  if serverIsRunning "\$(getAdminServerName)"; then
    # Wait for the administration server to start
    waitForAdminServer \$admin_server_start_timeout
    rc=$?
  else
    err "Administration Server failed to start."
    rc=1
  fi

  msg "See Administration Server stdout in $ASERVER_HOME/servers/\$(getAdminServerName)/logs/\$(getAdminServerName).out"
  return \$rc
}

start_stop_servers() {
  rc=0
  for srv in "\${servers[@]}"; do  # check if the admin and/or managed servers are included
    if [ "\$srv" == "\$(getAdminServerName)" ]; then
      adminServerIncluded="true"
    elif [ "\$srv" == "all" ]; then
      adminServerIncluded="true"
      managedServerIncluded="true"
    else
      managedServerIncluded="true"
    fi
  done

  # Obtain lock for admin server operations or return 1 if failed.
  if [ "\$adminServerIncluded" ]; then
    local i=0
    while ! getLock ADMINSRV_OPERATION; do
      ((i=i+1))
      if [ \$i -ge 12 ]; then
        err "Failed to obtain lock ADMINSRV_OPERATION"
        return 1
      fi
      msg "Waiting for lock ADMINSRV_OPERATION ..."
      sleep 5
    done
  fi


  # Start the administration server if needed.
  if [ "\$adminServerIncluded" == "true" ]; then
    if [ "\$command" == "start" ] || [ "\$command" == "multistart" ]; then
      start_adminserver
      rc=\$?
      releaseLock ADMINSRV_OPERATION
    fi
  fi
  [ "\$rc" != 0 ] && return \$rc

  # delegate the rest of work to controlServer.py
  if [ "\$command" == "stop" ] || [ "\$command" == "graceful_stop" ] || [ "\$command" == "multistop" ] || [ "\$command" == "graceful_multistop" ] || [ "\$managedServerIncluded" == "true" ]; then
    ./wlst.sh "controlServer.py" "\$command" \${servers[@]}
    rc=\$?
  fi

  # perform admin server post-shutdown tasks if needed
  if [ "\$adminServerIncluded" == "true" ]; then
    if [ "\$command" == "stop" ] || [ "\$command" == "multistop" ] || [ "\$command" == "graceful_stop" ] || [ "\$command" == "graceful_multistop" ]; then
      if [ "\$admin_flip_enabled" = "true" ]; then
        sleep 5 # TODO: wait+timeout instead of sleep

        flipDown # attempt to bring down the floating IP on this host
        if [ "\$?" -eq 10 ]; then
          # rc 10 means the floting IP was not up on this host
          # so try to bring it down on all other hosts of the domain
          readDomainConfig
          for machine in \${DOMAIN_MACHINE_LIST[@]}; do
            if [ "\$machine" != "\$(hostname)" ]; then
              ssh \$machine ". \$workdir/functions.sh; flipDown"
            fi
          done
        fi

      fi
    fi
  fi
  releaseLock ADMINSRV_OPERATION
  return \$rc
}

# Show the process status
status_servers() {
  readDomainConfig

  local status

  for s_available in \${DOMAIN_SERVER_LIST[@]}; do
    status="status=DOWN"
    for s_requested in "\${servers[@]}"; do
      if [ "\$s_available" == "\$s_requested" ] || [ "\$s_requested" == "all" ]; then
        for machine in \${DOMAIN_MACHINE_LIST[@]}; do
          if serverIsRunning "\$s_available" "\$machine" "use_cache"; then
            local pid="\$(echo \$process|cut -d ' ' -f 1)"
            status="status=UP   host=\$machine  pid=\$pid"
            break
          fi
        done
        echo "\$s_available  (\$status)"
      fi
    done
  done
}

# Start the node manager
start_nodemanager() {
  local rc=0
  if nmIsRunning; then
    nmpid="\$(echo \$process|cut -d ' ' -f 1)"
    msg "Nodemanager is already running on host \$(hostname) with pid \$nmpid"
  else
    msg "Starting Nodemanager on host \$(hostname) ... "
    nohup "$MSERVER_HOME/bin/startNodeManager.sh" >"$MSERVER_HOME/nodemanager/nodemanager.out" 2>&1 &
    sleep 7
    if nmIsRunning; then
      msg "Done."
    else
      msg "Failed to start the Nodemanager"
      rc=1
    fi
    msg "See Nodemanager stdout in \$(readlink -f $MSERVER_HOME/nodemanager/nodemanager.out)"
  fi
  return \$rc
}

# Stop the node manager
stop_nodemanager() {
  local rc=0

  if nmIsRunning; then
    nmpid="\$(echo \$process|cut -d ' ' -f 1)"
    msg "Terminating the Nodemanager on host \$(hostname) with PID \$nmpid ... "
    kill \$nmpid
    sleep 5
    if nmIsRunning; then
      msg "Failed to terminate the Nodemanager process"
      rc=1
    fi
  else
    msg "Nodemanager is not running on host \$(hostname)."
  fi
  return \$rc
}

# Show nodemanager status
status_nodemanager() {
  local status
  if nmIsRunning; then
    local nmpid="\$(echo \$process|cut -d ' ' -f 1)"
    status="status=UP   host=\$(hostname)  pid=\$nmpid"
  else
    status="status=DOWN host=\$(hostname)"
  fi
  echo "Nodemanager  (\$status)"
}


wls_state_servers() {
  wlstq controlServer.py status \${servers[@]}
}


########
# main #
########


# Check commad line options
if [ \$# -gt 0 ]; then
  command="\$1"
else
  echo "Error: Invalid options" >&2
  echo "\$usage_msg" >&2
  exit 1
fi

if [ "\$command" == "start" ] || [ "\$command" == "stop" ] || [ "\$command" == "graceful_stop" ] || [ "\$command" == "multistart" ] || [ "\$command" == "multistop" ] || [ "\$command" == "graceful_multistop" ] || [ "\$command" == "status" ] || [ "\$command" == "wls-state" ]; then
  if [ "\$2" ]; then
    servers=("\${@:2}")
  else
    echo "Error: no servers specified." >&2
    echo "\$usage_msg" >&2
    exit 1
  fi

  if [ "\$command" == "start" ] || [ "\$command" == "stop" ] || [ "\$command" == "graceful_stop" ] || [ "\$command" == "multistart" ] || [ "\$command" == "multistop" ] || [ "\$command" == "graceful_multistop" ]; then
    start_stop_servers
  elif [ "\$command" == "status" ]; then
    status_servers
  elif [ "\$command" == "wls-state" ]; then
    wls_state_servers
  fi

elif [ "\$command" == "nmstart" ] || [ "\$command" == "nmstop" ] || [ "\$command" == "nmstatus" ]; then
  if [ "\$2" ]; then
    machines=("\${@:2}")
  else
    machines="all"
  fi
  readDomainConfig
  rc=0
  for m_available in \${DOMAIN_MACHINE_LIST[@]}; do
    for m_requested in \${machines[@]}; do
      if [ "\$m_available" == "\$m_requested" ] || [ "\$m_requested" == "all" ]; then
        if [ "\$command" == "nmstart" ]; then
          if [ "\$(hostname)" == "\$m_available" ]; then
            start_nodemanager
          else
            ssh "\$m_available" "\$workdir/\$(basename \$0) nmstart \$m_available"
          fi
        elif [ "\$command" == "nmstop" ]; then
          if [ "\$(hostname)" == "\$m_available" ]; then
            stop_nodemanager
          else
            ssh "\$m_available" "\$workdir/\$(basename \$0) nmstop \$m_available"
          fi
        elif [ "\$command" == "nmstatus" ]; then
          if [ "\$(hostname)" == "\$m_available" ]; then
            status_nodemanager
          else
            ssh "\$m_available" "\$workdir/\$(basename \$0) nmstatus \$m_available"
          fi
        fi
      fi
      rc=\$((rc + \$?))
    done
  done
  [ \$rc -eq 0 ] # set return code from the elif block
else
  echo "Unknown commnand: \$command" >&2
  echo "\$usage_msg" >&2
  exit 1
fi
EOF

# Create a code fragment that can be included in multiple WLST files.
# This is a workaround for WLST modularity problems with global variables when importing modules.
# See: https://rhpatrickblog.wordpress.com/2015/10/16/wlst-in-fusion-middleware-12-2-1/
cat >$workdir/temp/python_common <<EOF
### Begin include python_common ###
import time as systime
import os
import socket as sck

def msg(message):
    tstamp = systime.strftime("%Y-%m-%dT%H:%M:%S", systime.localtime())
    host = sck.gethostname()
    scriptname = os.path.basename(sys.argv[0])
    print("[%s] [%s] [%s] [%s]" % (tstamp, host, scriptname, message))

class DomainConfig:

    domain = None
    connect_urls = None

    def __init__(self):
        if DomainConfig.domain is None:
            msg("Reading domain configuration.")
            readDomain("$ASERVER_HOME")
            cd("/")
            DomainConfig.domain = cmo
            admin_protocol = cmo.getAdministrationProtocol()
            admin_port_enabled = cmo.isAdministrationPortEnabled()
            DomainConfig.connect_urls = dict()
            for server in cmo.getServers():
                if admin_protocol == "t3":
                    connect_port = server.getListenPort()
                elif admin_protocol == "t3s":
                    if admin_port_enabled:
                        connect_port = server.getAdministrationPort()
                    else:
                        cd ("/Server/" + server.getName() + "/SSL/NO_NAME_0")
                        connect_port = cmo.getListenPort()
                else:
                    raise ValueError("Unexpected administration protocol in domain configuration: " + admin_protocol)

                server_listen_address = server.getListenAddress()
                if server_listen_address == "All Local Addresses":
                    server_listen_address = "localhost"
                DomainConfig.connect_urls[server.getName()] = admin_protocol + "://" + server_listen_address + ":" + str(connect_port)

    def get_domain(self):
        return DomainConfig.domain

    def get_connect_url(self, server_name):
        return DomainConfig.connect_urls[server_name]


# Connect to the specified server. Wait for max 'timeout' seconds for the
# connection.
def wait_and_connect(server, timeout):
    if connected and serverName == server:  # connected is wlst global variable
        msg("Already connected to server " + server)
        return
    else:
        url = DomainConfig().get_connect_url(server)
        user_config = '$ASERVER_HOME/custom_scripts/userConfig'
        user_key = '$ASERVER_HOME/custom_scripts/userKey'
        retry_delay = 10
        time_to_give_up = systime.time() + timeout
        conn_ok = False  # Flag connected


        while not conn_ok:
            try:
                connect(userConfigFile=user_config, userKeyFile=user_key, url=url)
                conn_ok = True
            except:
                if systime.time() + retry_delay > time_to_give_up:
                    break
                msg('Connection attempt to ' + url + ' failed. Waiting ' + str(retry_delay) + ' seconds ...')
                systime.sleep(retry_delay)
        if not conn_ok:
            raise RuntimeError('Could not connect to server ' +  server + ' at ' + url)

# Expands the list of specified server, cluster and machine names to valid server names.
# Cluster names and machine names will be resolved to the associated server names.
def resolve_to_servers(mbean_names):
    valid_servers = []
    for mbean_requested in mbean_names:
        for server in DomainConfig().get_domain().getServers():
            if ((mbean_requested == "all" or
                mbean_requested == server.getName() or
                (server.getCluster() is not None and mbean_requested == server.getCluster().getName()) or
                (server.getMachine() is not None and mbean_requested == server.getMachine().getName()))
                and
                (server.getName() not in valid_servers)
            ):
                valid_servers.append(server.getName())
    return valid_servers

### End include python_common ###
EOF

# Create controlServer.py
cat >$scriptdir/controlServer.py <<EOF
$header_msg
#
# Start/stop weblogic servers
#
import sys

# Start include python_common
$(cat $workdir/temp/python_common)
# End include python_common

# Start up the specified managed servers. Starting the Administration server is
# not supported.
#
# Parameters:
# servers_names: list of server names to start.
#                If the list includes the string "all" then all managed servers
#                in the domain will be started.
#                If the list includes the name of a cluster then all servers in
#                the cluster will be started.
#                If the list includes the name of a machine then all servers
#                assigned to the machine will be started.
# parallel: when True, the servers are started simultaneously
#           when False, the servers are started sequentially in the order as they appear in the server_names list
def start_servers(server_names, parallel):
    valid_server_names = resolve_to_servers(server_names)
    if len(valid_server_names) == 0:
        raise ValueError("No valid servers specified.")

    wait_and_connect(DomainConfig().get_domain().getAdminServerName(), 300)
    task_list = []
    for server in valid_server_names:
        server_state = getMBean("domainRuntime:/ServerLifeCycleRuntimes/" + server).getState()
        if server_state in ["SUSPENDING", "FORCE_SUSPENDING", "SHUTTING_DOWN"]:
            msg("Server " + server + " is currently in state " + server_state + " and cannot be started.")
        elif server_state in ["STARTING", "STANDBY", "ADMIN", "RESUMING", "RUNNING"]:
            msg("Server " + server + " has already been started. State = " + server_state)
        else:
            if parallel:
                task_list.append(start(server, block = "false"))
            else:
                start(server, block = "true")
    if parallel:
        while len(task_list) > 0:
            for task in task_list:
                sys.stdout.write(".")
                if task.getStatus() != "TASK IN PROGRESS":
                  task_list.remove(task)
            sys.stdout.write(" ")
            sys.stdout.flush()
            systime.sleep(4)
    print
    disconnect()

# Shut down the specified managed servers.
# Note: Stopping the Administration server is not supported.
#
# Parameters:
# servers_names: list of server names to shut down.
#                If the list includes the string "all" then all managed servers
#                in the domain will be stopped.
#                If the list includes the name of a cluster then all servers in
#                the cluster will be stopped.
#                If the list includes the name of a machine then all servers
#                assigned to the machine will be stopped.
# parallel: when True, the servers are stopped simultaneously
#           when False, the servers are stopped sequentially in the order as they appear in the server_names list
# graceful: when True, the servers will wait for application processing to complete before shutting down.
#           when False, the servers are stopped forcefully.
def stop_servers(server_names, parallel, graceful):
    valid_server_names = resolve_to_servers(server_names)
    if len(valid_server_names) == 0:
        raise ValueError("No valid servers specified.")

    if len(valid_server_names) > 1:
        try:
            msg("Connecting to the Administration Server to shut down servers ...")
            wait_and_connect(DomainConfig().get_domain().getAdminServerName(), 0)
            direct_connect = False
        except RuntimeError:
            msg("The Administration Server is not available. Shutting down the servers one by one.")
            direct_connect = True
    else:
        direct_connect = True

    if graceful:
      forceflag = "false"
    else:
      forceflag = "true"
      
    if direct_connect:
        for server in valid_server_names:
            try:
                msg("Trying to connect to server " + server + " to shut it down ...")
                wait_and_connect(server, 0)
                shutdown(force=forceflag)
            except RuntimeError:
                msg("Cannot connect to " + server + ". This server may already be down.")

    else:
        task_list = []

        stop_admin_server = False
        for server in valid_server_names:
            if server == DomainConfig().get_domain().getAdminServerName():
                stop_admin_server = True  # set flag only. The admin server will be stopped as last
            else:
                server_state = getMBean("domainRuntime:/ServerLifeCycleRuntimes/" + server).getState()
                if server_state in ["SUSPENDING", "FORCE_SUSPENDING", "SHUTTING_DOWN", "SHUTDOWN"]:
                    msg("Server " + server + " is currently in state " + server_state + " and will be skipped.")
                else:
                    if parallel:
                        # task_list.append(shutdown(name=server, force=forceflag, block="false"))  # doesn't work :(
                        shutdown(name=server, force=forceflag, block="false")
                    else:
                        shutdown(name=server, force=forceflag, block="true")

        # Todo: wait for all parallel shutdown tasks to complete
        # if parallel:
            # print (task_list)
            # while len(task_list) > 0:
                # for task in task_list:
                    # print (task.getDescription() + " " + task.getStatus())
                    # if task.getStatus()  != "TASK IN PROGRESS":
                        # task_list.remove(task)
                # systime.sleep(4)

        if stop_admin_server:
            shutdown(name=DomainConfig().get_domain().getAdminServerName(), force=forceflag, block="true")

    if connected == "true":  # wlst global variable
        disconnect()

# Retrieves the the life cycle state of the specified servers.
# Returns a dictionary with server names a keys and server states as values
#
# Parameters:
#   servers_names: list of server names.
#                  The string "all" indicates all servers
#                  If the list includes the name of a cluster then state information for all servers in
#                  the cluster will be reported.
#                  If the list includes the name of a machine then state information for all servers
#                  assigned to the machine will be reported.
def get_server_state(server_names):
    valid_server_names = resolve_to_servers(server_names)
    if len(valid_server_names) == 0:
        raise ValueError("No valid servers specified.")


    direct_connect = False
    try:
        msg("Connecting to the Administration Server to query server state information ...")
        wait_and_connect(DomainConfig().get_domain().getAdminServerName(), 0)
    except RuntimeError:
        msg("Warning: The Administration Server is not available. We'll try to directly connect to the managed servers")
        direct_connect = True

    server_states = dict()
    if direct_connect:
        for server in valid_server_names:
            try:
                msg("Trying to connect to server " + server)
                wait_and_connect(server, 0)
                server_states[server] = getMBean("serverRuntime:/").getState()
                disconnect()
            except RuntimeError:
                msg("Warning: Cannot connect to server " + server)
                server_states[server] = "n/a"
    else:
        for server in valid_server_names:
            server_states[server] = getMBean("domainRuntime:/ServerLifeCycleRuntimes/" + server).getState()
        disconnect()

    return server_states

##########
#  Main  #
##########
def main():
    valid_commands = ("start", "stop", "graceful_stop", "multistart", "multistop", "graceful_multistop", "status")

    try:
        if len(sys.argv) < 2:
            raise ValueError("Invalid arguments")
        command = sys.argv[1]
        if command not in valid_commands:
            raise ValueError("Invalid command: " + command)
        servers = sys.argv[2:]
    except ValueError, e:
        print e
        usageInfo = "Usage: " + sys.argv[0] + " <command> <server-name|cluster-name|machine-name|all>..." + """
        commmand:
        start: start servers sequentially
        stop: stop servers sequentially
        multistart: start servers simultaneously
        multistop: stop servers simultaneously
        status: show the status of the server process"""
        sys.exit(usageInfo)

    if command == "start":
        start_servers(servers, False)
    elif command == "multistart":
        start_servers(servers, True)
    elif command == "stop":
        stop_servers(servers, False, False)
    elif command == "multistop":
        stop_servers(servers, True, False)
    elif command == "graceful_stop":
        stop_servers(servers, False, True)
    elif command == "graceful_multistop":
        stop_servers(servers, True, True)
    elif command == "status":
        server_states = get_server_state(servers)
        keys = server_states.keys()
        keys.sort()
        for server in keys:
            print("Server " + server + ": state = " + server_states[server])


if __name__ == "main" or __name__ == '__main__':
    main()
EOF

# Create jvm-options.py
cat >$scriptdir/jvm-options.py <<EOF
$header_msg
#
# Set or show the configured JVM arguments for WebLogic servers.
#
import sys

$(cat $workdir/temp/python_common)

##########
#  Main  #
##########
def main():
    valid_commands = ("show", "set", "add")

    try:
        if len(sys.argv) < 2:
            raise ValueError("Invalid arguments")
        command = sys.argv[1]
        if command not in valid_commands:
            raise ValueError("Invalid command: " + command)
        if command == "show":
            server_names = sys.argv[2:]
        else:
            if len(sys.argv) < 3:
                raise ValueError("Invalid arguments")
            jvmargs = sys.argv[2]
            server_names = sys.argv[3:]
    except ValueError, e:
        print e
        usageInfo = "Usage:\n" + sys.argv[0] + " <show> <server-name|cluster-name|machine-name|all>...\n" + sys.argv[0] + " <set|add> <jvm-options> <server-name|cluster-name|machine-name|all>..."
        sys.exit(usageInfo)


    valid_server_names = resolve_to_servers(server_names)
    if len(valid_server_names) == 0:
        raise ValueError("No valid servers specified.")

    if command == "show":
        # Connect as operator using key files - no need to ask for credentials
        wait_and_connect(DomainConfig().get_domain().getAdminServerName(), 0)
    else:
        # Connect as administrator - get credentials from the environment
        wlsAdminUser=os.environ['WLS_ADMIN_USER']
        wlsAdminPw=os.environ['WLS_ADMIN_PW']
        adm_url=DomainConfig().get_connect_url(DomainConfig().get_domain().getAdminServerName())
        connect(wlsAdminUser, wlsAdminPw, adm_url)
        edit()
        startEdit()

    for server in valid_server_names:
        jvmargs_old = get("/Servers/" + server + "/ServerStart/" + server + "/Arguments")
        if jvmargs_old is None:
            jvmargs_old = ""
        if command == "show":
                print("Java arguments " + server + ": [" + jvmargs_old + "]")
        else:
            if command == "set":
                jvmargs_new = jvmargs.strip()
            elif command == "add":
                jvmargs_new = jvmargs_old.strip() + " " + jvmargs.strip()

            if jvmargs_new != jvmargs_old:
                if get("/Servers/" + server + "/Machine") is None:
                    print("Warning: Java arguments for server " + server + " will not be changed. Server has no machine assigned.")
                else:
                    set("/Servers/" + server + "/ServerStart/" + server + "/Arguments", jvmargs_new)
                    print("Java arguments " + server + ": [" + jvmargs_new + "]")
    if command in ("set", "add"):
        save()
        activate()
    disconnect()

if __name__ == "main" or __name__ == '__main__':
    main()
EOF

# Create jvm-options.sh
cat >$scriptdir/jvm-options.sh <<EOF
#!/bin/bash
$header_msg
#
# Set or show the configured JVM arguments for WebLogic servers.
#
cd \$(dirname \$0); workdir="\$(pwd)"
. "\$workdir/functions.sh"

if [ "\$1" ] && [ "\$1" != "show" ]; then
  # Ask for WLS username and password if not set
  if [ -z "\$WLS_ADMIN_USER" ]; then
    echo -n "WebLogic administrator username: "
    read WLS_ADMIN_USER
    export WLS_ADMIN_USER
  fi
  if [ -z "\$WLS_ADMIN_PW" ]; then
    echo -n "Enter password: "
    stty -echo; read WLS_ADMIN_PW; stty echo
    echo
    export WLS_ADMIN_PW
  fi
fi

./wlst.sh jvm-options.py "\$@"
EOF

# Create addserver.sh
cat >$scriptdir/addserver.sh <<EOF
#!/bin/bash
$header_msg
#
cd \$(dirname \$0); workdir="\$(pwd)"
. "\$workdir/functions.sh"

usage_msg="Add new managed servers and optionally clusters to the domain.

Usage:
  \$(basename \$0) <configuration_file>

    configuration_file:
      For each new managed server specify a set of parameters like below in the configuration file:

      MACHINE[mserver-name]=machine              # The machine (host) for this managed server
      CLUSTER[mserver-name]=cluster-name         # The cluster that this managed server is a member of (optional)
      LISTENPORT[mserver-name]=port-number       # Plain listen port
      SSLPORT[mserver-name]=port-number          # SSL port
      ADMINPORT[mserver-name]=port-number        # Administration port
      LISTENADDRESS[mserver-name]=listen-address # Listen address

    Environment:
      The following environment varialbles will be used:

      WLS_ADMIN_USER:
        WebLogic adminitrator username. If not set, you will be prompted for the username.

      WLS_ADMIN_PW:
        WebLogic adminitrator password. If not set, you will be prompted for the password."


# Configuration parameters that will be treated as associative arrays
declare -A NM_LISTENADDRESS LISTENPORT SSLPORT ADMINPORT LISTENADDRESS MACHINE CLUSTER

# Read the configuration file
if [ \$# -gt 0 ]; then
  if [ -f "\$1" ]; then
      msg "Reading configuration from \$1"
      . "\$1" || exit 1
   else
      err "File not found: \$1"
      exit 1
   fi
else
  echo "\$usage_msg" >&2
  exit 1
fi

# Ask for WLS username and password if not set
if [ -z "\$WLS_ADMIN_USER" ]; then
  echo -n "WebLogic administrator username: "
  read WLS_ADMIN_USER
  export WLS_ADMIN_USER
fi
if [ -z "\$WLS_ADMIN_PW" ]; then
  echo -n "Enter password: "
  stty -echo; read WLS_ADMIN_PW; stty echo
  echo
  export WLS_ADMIN_PW
fi

# Get all server names from the configuration.
# Keys retrieved from the different associative arrays are all considered as server names.
SERVERS=(\$(echo "\${!LISTENADDRESS[@]}" "\${!LISTENPORT[@]}" "\${!SSLPORT[@]}" "\${!ADMINPORT[@]}" "\${!MACHINE[@]}" "\${!CLUSTER[@]}"|tr ' ' '\n'|sort|uniq))
if [ "\${#SERVERS[@]}" -eq 0 ]; then
  err "No servers have been specified."
  exit 1
fi

# Verify if all required server configuration parameters exist in the respective associative arrays.
readDomainConfig
error=0
for server in "\${SERVERS[@]}"; do
  for existing_server in  \${DOMAIN_SERVER_LIST[@]}; do
    if [ "\$server" == "\$existing_server" ]; then
      err "Server \$server already exists in the domain."
      exit 1
    fi
  done
  [ "\${LISTENADDRESS[\$server]}" ] || { err "Missing configuration: LISTENADDRESS[\$server]"; error=1; }
  [ "\${LISTENPORT[\$server]}" ] || { err "Missing configuration: LISTENPORT[\$server]"; error=1; }
  [ "\${SSLPORT[\$server]}" ] || { err "Missing configuration: SSLPORT[\$server]"; error=1; }
  [ "\${ADMINPORT[\$server]}" ] || { err "Missing configuration: ADMINPORT[\$server]"; error=1; }
  [ "\${MACHINE[\$server]}" ] || { err "Missing configuration: MACHINE[\$server]"; error=1; }
  # TODO: Check - The specified machine must exist. This script will not create new machines.
  [ "\${CLUSTER[\$server]}" ] || msg "INFO: Server \$server will not be a member of any cluster."
done
[ "\$error" -ne 0 ] && exit 1

# Generate WLST script
cat >/tmp/addserver.\$\$.py << EOF2
import getpass

$(cat $workdir/temp/python_common)

## MAIN ##
wlsAdminUser=os.environ['WLS_ADMIN_USER']
wlsAdminPw=os.environ['WLS_ADMIN_PW']
adm_url=DomainConfig().get_connect_url("\$(getAdminServerName)")

connect(wlsAdminUser, wlsAdminPw, adm_url)
edit()
startEdit()

EOF2

for cl in \$(echo "\${CLUSTER[@]}"|tr ' ' '\n'|sort|uniq); do
cat >>/tmp/addserver.\$\$.py << EOF2
# Create cluster \$cl
msg('Creating Cluster \$cl')
cd('/')
try:
    cmo.createCluster('\$cl')
    cd('/Clusters/\$cl')
    cmo.setClusterMessagingMode('unicast')
    cmo.setSecureReplicationEnabled(true)
except weblogic.descriptor.BeanAlreadyExistsException:
    msg("NOTICE: Cluster \$cl already exists.")

EOF2
done

for srv in "\${SERVERS[@]}"; do
cat >>/tmp/addserver.\$\$.py << EOF2
# Create managed server \$srv
msg('Creating managed server \$srv')
cd('/')
cmo.createServer('\$srv')
cd('/Servers/\$srv')
cmo.setMachine(getMBean('/Machines/\${MACHINE[\$srv]}'))
if '\${CLUSTER[\$srv]}':
    cmo.setCluster(getMBean('/Clusters/\${CLUSTER[\$srv]}'))


# Configure ports and listen addresses for \$srv
msg('Setting port numbers for \$srv')
cd('/Servers/\$srv')
cmo.setListenAddress('\${LISTENADDRESS[\$srv]}')
cmo.setListenPort(\${LISTENPORT[\$srv]})
if '$SSL_ONLY'.lower() == 'true':
    cmo.setListenPortEnabled(false)
    cmo.setDefaultProtocol('t3s')
cmo.setAdministrationPort(\${ADMINPORT[\$srv]})
cd('/Servers/\$srv/SSL/\$srv')
cmo.setEnabled(true)
cmo.setListenPort(\${SSLPORT[\$srv]})

# Set IuK37 standard java options
msg('Setting Java options for \$srv')
cd('/Servers/\$srv/ServerStart/\$srv')
cmo.setArguments("-Xloggc:servers/\$srv/logs/gc.%t.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Djavax.net.ssl.trustStore=$TRUST_STORE")
if '$weblogic_version' == '12.2.1.4':
    cmo.setArguments("-Xloggc:servers/\$srv/logs/gc.%t.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Djavax.net.ssl.trustStore=$TRUST_STORE")
else:
    cmo.setArguments("-Xlog:gc*:file=servers/\$srv/logs/gc.%t.log -Djavax.net.ssl.trustStore=$TRUST_STORE")

# Set timeout for graceful shutdown
msg('Set timeout for graceful shutdown on \$srv')
cd('/Servers/\$srv')
cmo.setGracefulShutdownTimeout(300)

# Configure SSL for \$srv
msg('Setting up SSL for \$srv')
cd('/Servers/\$srv')
cmo.setKeyStores('CustomIdentityAndCustomTrust')
cmo.setCustomIdentityKeyStoreFileName('$ID_STORE')
cmo.setCustomIdentityKeyStoreType('jks')
cmo.setCustomTrustKeyStoreFileName('$TRUST_STORE')
cmo.setCustomTrustKeyStoreType('jks')
cd('/Servers/\$srv/SSL/\$srv')
cmo.setServerPrivateKeyAlias('\${LISTENADDRESS[\$srv]}')
cmo.setHostnameVerificationIgnored(false)
cmo.setHostnameVerifier(None)
cmo.setTwoWaySSLEnabled(false)
cmo.setClientCertificateEnforced(false)
cmo.setJSSEEnabled(true)

# Set store and key passwords for SSL
idStorePassEncrypted = trustStorePassEncrypted = privateKeyPassEncrypted = None
cd("/")
for existing_server in cmo.getServers():
    if existing_server.getCustomIdentityKeyStoreFileName() == '$ID_STORE':
        #print(existing_server.getName() +  " has idStorePassEncrypted.")
        idStorePassEncrypted = existing_server.getCustomIdentityKeyStorePassPhraseEncrypted()

    if existing_server.getCustomTrustKeyStoreFileName() == '$TRUST_STORE':
        #print(existing_server.getName() +  " has trustStorePassEncrypted.")
        trustStorePassEncrypted = existing_server.getCustomTrustKeyStorePassPhraseEncrypted()

    cd("/Servers/" + existing_server.getName() + "/SSL/" + existing_server.getName())
    if cmo.getServerPrivateKeyAlias() == '\${LISTENADDRESS[\$srv]}':
        #print(existing_server.getName() +  " has privateKeyPassEncrypted.")
        privateKeyPassEncrypted = cmo.getServerPrivateKeyPassPhraseEncrypted()

    if (idStorePassEncrypted and trustStorePassEncrypted and privateKeyPassEncrypted):
        cd('/Servers/\$srv')
        cmo.setCustomIdentityKeyStorePassPhraseEncrypted(idStorePassEncrypted)
        cmo.setCustomTrustKeyStorePassPhraseEncrypted(trustStorePassEncrypted)
        cd('/Servers/\$srv/SSL/\$srv')
        cmo.setServerPrivateKeyPassPhraseEncrypted(privateKeyPassEncrypted)
        msg("Keystore and private key passwords have been taken over from existing servers to \$srv")
        break
else:
    msg("Couldn't find all required keystore and private key passwords in the domain. Enter the passwords manually.")
    if idStorePassEncrypted is None:
        cd('/Servers/\$srv')
        pw = getpass.getpass("Enter keystore password for $ID_STORE: ")
        cmo.setCustomIdentityKeyStorePassPhrase(pw)
    if trustStorePassEncrypted is None:
        cd('/Servers/\$srv')
        pw = getpass.getpass("Enter trust store password for $TRUST_STORE: ")
        cmo.setCustomTrustKeyStorePassPhrase(pw)
    if privateKeyPassEncrypted is None:
        cd('/Servers/\$srv/SSL/\$srv')
        msg("A private key entry with alias \${LISTENADDRESS[\$srv]} must already exist in the keystore $ID_STORE.")
        pw = getpass.getpass("Enter private key password: ")
        cmo.setServerPrivateKeyPassPhrase(pw)

msg('Setting log date format for \$srv')
cd('/Servers/\$srv/Log/\$srv')
cmo.setDateFormatPattern('yyyy-MM-dd HH:mm:ss.SSS')
msg('Turning off log rotation for \$srv')
cd('/Servers/\$srv/Log/\$srv')
cmo.setRotationType('none')
cd('/Servers/\$srv/WebServer/\$srv/WebServerLog/\$srv')
cmo.setRotationType('none')
cd('/Servers/\$srv/DataSource/\$srv/DataSourceLogFile/\$srv')
cmo.setRotationType('none')

EOF2
done

cat >>/tmp/addserver.\$\$.py << EOF2
activate()
disconnect()
EOF2

# Start the administration server
\$workdir/command-control.sh start \$(getAdminServerName) &&
  # Execute the generated wlst script to create the servers.
  ./wlst.sh /tmp/addserver.\$\$.py ||
  exit 1

rm /tmp/addserver.\$\$.py

# Log directories
for srv in "\${SERVERS[@]}"; do
  srv_dir="$MSERVER_HOME/servers/\$srv"
  srv_log_link="\$srv_dir/logs"
  srv_log_link_target="$LOGDIR_PATH/$WLS_OS_USER/$DOMAIN_NAME/servers/\$srv"

  cmd="mkdir -p \$srv_log_link_target/rotated && mkdir -p \$srv_dir && ln -fsT \$srv_log_link_target \$srv_log_link"
  if [ \${MACHINE[\$srv]} == "\$(hostname)" ]; then
    msg "Creating directories for server \$srv on host \$(hostname)"
    eval "\$cmd" || exit 1
  else
    msg "Creating directories for server \$srv on host \${MACHINE[\$srv]}"
    ssh -o BatchMode=yes \${MACHINE[\$srv]} "\$cmd" || exit 1
  fi
done

EOF

# Create menu-control.sh
cat >$scriptdir/menu-control.sh <<EOF
#!/bin/bash
$header_msg
#
# Ineractive wrapper script for command-control.sh to start, stop or show the status of WebLogic Servers
#
cd \$(dirname \$0); workdir="\$(pwd)"
. \$workdir/functions.sh

# Check if a machine with the name \$1 exists.
isMachine() {
  for i in "\${DOMAIN_MACHINE_LIST[@]}"; do
      [ "\$i" == "\$1" ] && return 0
  done
  return 1
}

# check if \$1 is a number
isNumber() {
  [[ \$1 =~ ^[0-9]+\$ ]]
}

# Main
readDomainConfig

all_components=(\${DOMAIN_MACHINE_LIST[@]} \${DOMAIN_SERVER_LIST[@]})

go="true"
while [ "\$go" = "true" ]; do
  printf "\\033c" # clear terminal but allow to scroll back
  echo "-------------------------------------------------------------------------------------"
  echo "WebLogic Control Menu  $DOMAIN_NAME            \$(date)"
  echo "-------------------------------------------------------------------------------------"
  cnt=0
  for i in "\${all_components[@]}"; do
    echo "\$((cnt+=1)) = \$i"
  done
  echo "-------------------------------------------------------------------------------------"
  echo "<start|stop|graceful-stop|status> <item-nr>...  - Start/stop/status of selected items"
  echo "                                                  (e.g. start 1-3 5 7 9-11)"
  echo "<exit>                                          - Exit to shell."
  echo "-------------------------------------------------------------------------------------"
  echo -n "Wait ..."

  readarray -t all_status < <(./command-control.sh nmstatus all && ./command-control.sh status all)

  printf "\\033c" # clear terminal but allow to scroll back
  echo "-------------------------------------------------------------------------------------"
  echo "WebLogic Control Menu  $DOMAIN_NAME            \$(date)"
  echo "-------------------------------------------------------------------------------------"
  cnt=0
  for i in "\${all_status[@]}"; do
    echo "\$((cnt+=1)) = \$i"
  done
  echo "-------------------------------------------------------------------------------------"
  echo "<start|stop|graceful-stop|status> <item-nr>...  - Start/stop/status of selected items"
  echo "                                                  (e.g. start 1-3 5 7 9-11)"
  echo "<exit>                                          - Exit to shell."
  echo "-------------------------------------------------------------------------------------"
  echo -n "Ready> "
  read operation selection_with_ranges

  unset selcted_machines selcted_servers
  eval selected_items=(\$(echo \$selection_with_ranges | perl -pe 's/-/\.\./g; s/\d*\.\.\d*/{\$&}/g;'))

  for item in "\${selected_items[@]}"; do
    err="false"
    if isNumber "\$item" && [ "\$item" -gt 0 ] && [ "\$item" -le \${#all_components[@]} ]; then
      index=\$((item-1))
      if isMachine "\${all_components[\$index]}"; then
        selcted_machines+=("\${all_components[\$index]}")
      else
        selcted_servers+=("\${all_components[\$index]}")
      fi
    else
      echo "Invalid selection: \$item"
      err="true"
    fi
  done
  if [ "\$err" = "true" ]; then
    read -n 1 -p "Press any key to continue..."
    continue
  fi

  if [ "\$operation" == "exit" ] || [ "\$operation" == "e" ]; then
    exit 0
  elif [ "\$operation" == "start" ]; then
    [ "\${selcted_machines[*]}" ] && ./command-control.sh nmstart "\${selcted_machines[@]}"
    [ "\${selcted_servers[*]}" ] && ./command-control.sh multistart "\${selcted_servers[@]}"
  elif [ "\$operation" == "stop" ]; then
    [ "\${selcted_servers[*]}" ] && ./command-control.sh multistop "\${selcted_servers[@]}"
    [ "\${selcted_machines[*]}" ] && ./command-control.sh nmstop "\${selcted_machines[@]}"
  elif [ "\$operation" == "graceful-stop" ]; then
    [ "\${selcted_servers[*]}" ] && ./command-control.sh graceful_multistop "\${selcted_servers[@]}"
    [ "\${selcted_machines[*]}" ] && ./command-control.sh nmstop "\${selcted_machines[@]}"
  elif [ "\$operation" == "status" ]; then
    [ "\${selcted_machines[*]}" ] && ./command-control.sh nmstatus "\${selcted_machines[@]}"
    [ "\${selcted_servers[*]}" ] && ./command-control.sh wls-state "\${selcted_servers[@]}"
  else
    echo "Invalid operation: \$operation"
    read -n 1 -p "Press any key to continue..."
    continue # while
  fi
  read -n 1 -p "Press any key to continue..."
done
EOF

chmod u+x $scriptdir/*.sh
chmod u-x $scriptdir/functions.sh
